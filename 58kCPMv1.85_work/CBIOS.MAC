;
; *****
; ***** ADS CP/M BIOS
; ***** TOM DE LELLIS
; ***** 9/15/86
; *****
;
	.Z80
	CSEG
;
	PUBLIC	PRMSG
	PUBLIC	DIRBF
	PUBLIC	UDSECBF
	PUBLIC	UDUNIT
	PUBLIC	UDTRACK
	PUBLIC	UDSECTR
	PUBLIC	DRVTYP
	PUBLIC	DPHTBL
	PUBLIC	HSTDSK
	PUBLIC	HSTTRK
	PUBLIC	HSTSEC
	PUBLIC	HSTSIZ
	PUBLIC	HSTBUF
	PUBLIC	ERFLAG
;
	EXTRN	CRTOUT
	EXTRN	KBIN
	EXTRN	CONST
	EXTRN	ZCPR
	EXTRN	BDOS
	EXTRN	STACK
	EXTRN	INIT
	EXTRN	REINIT
	EXTRN	DEFDSK
	EXTRN	DEFUSR
	EXTRN	UL1ST
	EXTRN	UL1OUT
	EXTRN	UR1IST
	EXTRN	UR1IN
	EXTRN	UR2IST
	EXTRN	UR2IN
	EXTRN	UP1OUT
	EXTRN	UP2OUT
	EXTRN	LISTST
	EXTRN	LISTOT
	EXTRN	PTPOUT
	EXTRN	PTRIN
	EXTRN	PTRIST
	EXTRN	TTYIST
	EXTRN	TTYOST
	EXTRN	TTYOUT
	EXTRN	TTYIN
	EXTRN	DPHFP0
	EXTRN	DPHFP1
	EXTRN	DPHFP2
	EXTRN	DPHFP3
	EXTRN	DPHM1
	EXTRN	DPHM2
	EXTRN	DPHD0
	EXTRN	DPHD1
	EXTRN	DPHD2
	EXTRN	DPHD3
	EXTRN	DPHD4
;
BEL	EQU	X'07'			; BELL
LF	EQU	X'0A'			; LINEFEED
CR	EQU	X'0D'			; CARRIGE RETURN
;
NSECTS	EQU	X'1600'/128		; (LEN(CCP)+LEN(BDOS))/128
;
IOBYTE	EQU	X'0003'			; LOCATION OF CP/M I/O BYTE
CURDSK	EQU	X'0004'			; LOCATION OF CURRENT USER/DISK
;
OFSTLOG	EQU	-2			; OFFSET FOR DISK LOGIN
OFSTRD	EQU	-4			; OFFSET FOR DISK READ
OFSTWR	EQU	-6			; OFFSET FOR DISK WRITE
;
; *****
; ***** DEBLOCKER PARAMETERS
; *****
;
BLKSIZ	EQU	4096			; CP/M ALLOCATION SIZE (MATCHES HDISK)
HSTSIZ	EQU	512			; HOST DISK SECTOR SIZE
HSTSPT	EQU	24			; HOST DISK SECTORS/TRK
HSTBLK	EQU	HSTSIZ/128		; CP/M SECTS/HOST BUFF
CPMSPT	EQU	HSTBLK*HSTSPT		; CP/M SECTORS/TRACK
SECMSK	EQU	HSTBLK-1		; SECTOR MASK
SECSHF	EQU	2			; LOG2(HSTBLK)
;
WRALL	EQU	0			; WRITE TO ALLOCATED
WRDIR	EQU	1			; WRITE TO DIRECTORY
WRUAL	EQU	2			; WRITE TO UNALLOCATED
;
; *****
; ***** CBIOS JUMP TABLE
; *****
;
	JP	BOOT			; COLD BOOT
WBOOTE:
	JP	WBOOT			; WARM BOOT
	JP	ICONST			; CONSOLE DEVICE STATUS
	JP	ICONIN			; CONSOLE DEVICE INPUT
	JP	ICONOT			; CONSOLE DEVICE OUTPUT
	JP	ILISTOT			; LIST DEVICE OUTPUT
	JP	IPUNCH			; PUNCH DEVICE OUTPUT
	JP	IREADER			; READER DEVICE INPUT
	JP	HOME			; HOME CURRENT DISK'S HEAD TO TRACK 0
	JP	SELDSK			; SELECT DISK
	JP	SETTRK			; SET TRACK
	JP	SETSEC			; SET SECTOR
	JP	SETDMA			; SET DMA ADDRESS
	JP	IREAD			; READ SECTOR
	JP	IWRITE			; WRITE SECTOR
	JP	ILISTST			; LIST DEVICE STATUS
	JP	SECTRAN			; SECTOR SKEW TRANSLATION
;
; *****
; ***** COLD BOOT
; *****
;
BOOT:
	LD	SP,STACK		; SET STACK
	CALL	INITALLOC		; INITIALIZE DEBLOCKER
	CALL	INIT			; INITIALIZE BOARDS
	XOR	A			; DISK A:, USER 0
	LD	C,A			; FOR SELDSK CALL
	LD	(CURDSK),A		; STORE CURRENT USER/DISK
	CALL	SELDSK			; SET CURDPH
	CALL	GOCPM			; GET READY TO GOTO CCP
	JP	ZCPR			; GOTO CCP AND PROCESS DEFAULT CMND
;
; *****
; ***** WARM BOOT
; *****
;
WBOOT:
	LD	SP,STACK		; SET STACK
	CALL	INITALLOC		; INITIALIZE DEBLOCKER
;
	IN	A,(X'F0')		; GET ADS KEYBOARD DATA REGARDLESS
	CP	X'F6'			; WAS THE <RESET> KEY PRESSED?
	JR	NZ,WBOOT0		; IF NOT, SKIP THIS STUFF
	IN	A,(X'F2')		; RESTORE ADS KEYBOARD STATUS
;
	CALL	REINIT			; RE-INITIALIZE BOARDS
WBOOT0:
	LD	BC,ZCPR			; LOAD ADDRESS OF CCP
	CALL	SETDMA			; SET IT
	LD	A,(CURDSK)		; GET DISK WE ARE ON
	AND	X'0F'			; REMOVE USER NUMBER
	LD	C,A			; INTO C FOR BIOS CALL
	CALL	SELDSK			; SELECT CURRENT DISK FOR BOOTING
	CALL	HOME			; GOTO TRACK 0
	LD	C,5			; START READ AT SECTOR 5
	CALL	SETSEC			; SET SECTOR
	LD	B,NSECTS		; NUMBER OF SECTORS TO READ
RDSEC:
	PUSH	BC			; SAVE NUMBER OF SECTORS
	CALL	IREAD			; READ THE SECTOR
	OR	A			; ANY READ ERRORS?
	JR	Z,RDSECOK		; IF NOT, JUMP
	LD	HL,BOOTMSG		; GET BOOT ERROR MESSAGE
	CALL	PRMSG			; PRINT IT
HALTAGN:
	HALT				; TRY TO GRIND TO A HALT
	JR	HALTAGN			; MAKE SURE
RDSECOK:
	LD	HL,(UDSECBF)		; GET CURRENT CCP LOAD ADDRESS
	LD	DE,128			; GET READY TO ADD 128 TO IT
	ADD	HL,DE			; ADD 128 TO CCP LOAD ADDRESS
	LD	(UDSECBF),HL		; STORE IT BACK
	LD	HL,(CURDPH)		; GET CURRENT DPH
	LD	DE,X'000A'		; OFFSET TO DPB ADDRESS
	ADD	HL,DE			; ADD OFFSET TO DPH
	LD	E,(HL)			; GET LSB DPB ADDRESS
	INC	HL			; POINT TO MSB
	LD	D,(HL)			; GET MSB DPB ADDRESS
	LD	A,(DE)			; GET SPT
	LD	B,A			; INTO B FOR COMPARE
	LD	A,(UDSECTR)		; GET THE SECTOR WE ARE ON
	INC	A			; NEXT SECTOR
	CP	B			; PAST THE LAST SECTOR?
	JR	C,RD2			; IF NOT, THEN READ NEXT SECTOR
	LD	A,(UDTRACK)		; GET THE TRACK WE ARE ON
	INC	A			; INCREMENT
	LD	(UDTRACK),A		; STORE TRACK BACK
	XOR	A			; GET A 0
RD2:
	LD	(UDSECTR),A		; STORE IT BACK
	POP	BC			; RESTORE SECTOR COUNT
	DJNZ	RDSEC			; DECREMENT AND READ NEXT
	CALL	GOCPM			; GET READY TO GOTO THE CCP
	JP	ZCPR+X'0003'		; GOTO CCP AND DON'T DO DEFAULT CMND
;
; *****
; ***** SET UP ZERO PAGE STUFF
; *****
;
GOCPM:
	LD	BC,X'0080'		; DEFAULT DMA BUFFER
	CALL	SETDMA			; SET IT
	LD	A,X'C3'			; X'C3' = JP
	LD	(0),A			; STORE FOR BIOS JUMP
	LD	(5),A			; STORE FOR BDOS JUMP
	LD	HL,WBOOTE		; WARM BOOT ENTRY ADDR
	LD	(1),HL			; STORE IT
	LD	HL,BDOS+6		; BDOS LOAD ADDR + 6 = ENTRY BDOS ADDR
	LD	(6),HL			; STORE IT
	LD	A,(CURDSK)		; GET DISK WE ARE ON
	LD	C,A			; INTO C FOR CCP ENTRY
	LD	B,A			; SAVE IT TEMPORARILY
	AND	X'0F'			; REMOVE USER NUMBER
	LD	(DEFDSK),A		; STORE IT INTO BDOS
	LD	A,B			; RECALL CURDSK
	RRA				; SHIFT
	RRA				;  USER NUMBER
	RRA				;   INTO
	RRA				;    LOWER BITS
	AND	X'0F'			; REMOVE ANYTHING ELSE JUST IN CASE
	LD	(DEFUSR),A		; STORE USER NUMBER INTO BDOS
	RET				; RETURN
;
; *****
; ***** INITIALIZE DEBLOCKER
; *****
;
INITALLOC:
	XOR	A			; 0 TO ACCUMULATOR
	LD	(HSTACT),A		; HOST BUFFER INACTIVE
	LD	(UNACNT),A		; CLEAR UNALLOC COUNT
	RET				; EXIT
;
; *****
; ***** I/O BYTE ROUTER
; *****
;
ICONST:
	XOR	A			; SHIFT I/O BYTE 0 BITS RIGHT
	LD	HL,TCONST		; POINTER TO CONSOLE STATUS TABLE
	JP	IOVECTR			; GOTO ROUTINE
ICONIN:
	XOR	A			; SHIFT I/O BYTE 0 BITS RIGHT
	LD	HL,TCONIN		; POINTER TO CONSOLE INPUT TABLE
	JP	IOVECTR			; GOTO ROUTINE
ICONOT:
	XOR	A			; SHIFT I/O BYTE 0 BITS RIGHT
	LD	HL,TCONOT		; POINTER TO CONSOLE OUTPUT TABLE
	JP	IOVECTR			; GOTO ROUTINE
IRDRST:
	LD	A,1			; SÈIFT I/O BYTE 2 BITS RIGHT
	LD	HL,TRDRST		; POINTER TO READER STATUS TABLE
	JP	IOVECTR			; GOTO ROUTINE
IREADER:
	LD	A,1			; SHIFT I/O BYTE 2 BITS RIGHT
	LD	HL,TREADER		; POINTER TO READER INPUT TABLE
	JP	IOVECTR			; GOTO ROUTINE
IPUNCH:
	LD	A,2			; SHIFT I/O BYTE 4 BITS RIGHT
	LD	HL,TPUNCH		; POINTER TO PUNCH OUTPUT TABLE
	JP	IOVECTR			; GOTO ROUTINE
ILISTST:
	LD	A,3			; SHIFT I/O BYTE 6 BITS RIGHT
	LD	HL,TLISTST		; POINTER TO LIST STATUS TABLE
	JP	IOVECTR			; GOTO ROUTINE
ILISTOT:
	LD	A,3			; SHIFT I/O BYTE 6 BITS RIGHT
	LD	HL,TLISTOT		; POINTER TO LIST OUTPUT TABLE
	JP	IOVECTR			; GOTO ROUTINE
;
; *****
; ***** GENERATE EXIT STATUS, READY OR ERROR
; *****
;
ERRST:
	LD	A,X'FF'			; DEVICE IS READY/ERROR
	RET				; RETURN
;
; *****
; ***** SELECT DISK GIVEN BY REG. C
; *****
;
SELDSK:
	LD	HL,X'0000'		; INVALID DRIVE DPH
	LD	A,C			; GET DISK NUMBER INTO A
	CP	16			; IS DRIVE > MAX DRIVES AVAILABLE?
	RET	NC			; RETURN IF SO
	RLCA				; DISK NUMBER TIMES 2
	ADD	A,C			; TIMES 3
	LD	HL,DPHTBL		; DISK TABLE BASE
	LD	D,0			; ZERO D
	LD	E,A			; OFFSET INTO E
	ADD	HL,DE			; ADD OFFSET TO BASE
	LD	E,0			; ZERO E SO THAT DE = 0 FOR ACTIVE TEST
	LD	A,(HL)			; GET DISK DRIVER TYPE
	BIT	3,A			; IS DRIVE ACTIVE?
	JR	Z,SELEXIT		; JUMP IF NOT
	LD	(DRVTYP),A		; SAVE IT
	AND	X'07'			; KEEP ONLY UNIT ID
	LD	B,A			; SAVE FOR UNIT MERGE
	INC	HL			; NEXT PARAM
	LD	E,(HL)			; GET LOW BYTE OF DPH
	INC	HL			; INCREMENT
	LD	D,(HL)			; GET THE HIGH BYTE
SELEXIT:
	EX	DE,HL			; PUT IT INTO HL
	LD	A,H			; WAS DRIVE
	OR	L			;  UNDEFINED?
	RET	Z			; RETURN IF SO
	LD	(CURDPH),HL		; ELSE STORE IT
	LD	A,C			; GET CP/M DRIVE ID
	RLA				; SHIFT
	RLA				;  INTO
	RLA				;   HIGH
	RLA				;    NIBBLE
	AND	X'F0'			; MASK OUT ANY GARBAGE
	OR	B			; MERGE WITH UNIT ID
	LD	(UDUNIT),A		; STORE UNIQUE UNIT
	RET				; EXIT
;
; *****
; ***** HOME DISK HEAD TO TRACK 0
; *****
;
HOME:
	LD	A,(HSTWRT)		; GET PENDING WRITE FLAG
	OR	A			; PENDING WRITE?
	JR	NZ,HOMED		; JUMP IF PENDING WRITE
	LD	(HSTACT),A		; ELSE CLEAR HOST ACTIVE FLAG
HOMED:
	LD	BC,0			; SET TRACK 0, FALL THRU
;
; *****
; ***** SET TRACK GIVEN BY REG. BC
; *****
;
SETTRK:
	LD	(UDTRACK),BC		; STORE TRACK NUMBER
	RET				; EXIT
;
; *****
; ***** SET SECTOR GIVEN BY REG. C
; *****
;
SETSEC:
	LD	A,C			; GET SECTOR INTO A
	LD	(UDSECTR),A		; STORE SECTOR
	RET				; EXIT
;
; *****
; ***** TRANSLATE SECTOR NUMBER IN REG. BC USING TABLE IN REG. DE
; *****
;
SECTRAN:
	EX	DE,HL			; PUT TABLE ADDRESS INTO HL
	ADD	HL,BC			; ADD SECTOR NUMBER
	LD	L,(HL)			; GET SECTOR SKEW
	LD	H,0			; ZERO H, LESS THAN 256 SECTORS
	RET				; EXIT
;
; *****
; ***** SET DMA ADDRESS GIVEN BY REG. BC
; *****
;
SETDMA:
	LD	(UDSECBF),BC		; STORE DMA ADDRESS
	RET				; EXIT
;
; *****
; ***** READ SECTOR
; *****
;
IREAD:
	LD	A,(DRVTYP)		; GET DISK DRIVER TYPE
	RLA				; IS IT A NON-DEBLOCKED DRIVE?
	JP	NC,READHST		; JUMP IF SO, DIRECT SECTOR READ
	XOR	A			; ZERO A
	LD	(UNACNT),A		; CLEAR UNALLOCATED COUNT
	LD	A,WRUAL			; SET WRITE TO UNALLOCATED
	LD	(READOP),A		; READ OPERATION
	LD	(RSFLAG),A		; MUST READ DATA
	LD	(WRTYPE),A		; TREAT AS UNALLOC
	JP	RWOPER			; TO PERFORM THE READ
;
; *****
; ***** WRITE SECTOR
; *****
;
IWRITE:
	LD	A,(DRVTYP)		; GET DISK DRIVER TYPE
	RLA				; IS IT A NON-DEBLOCKED DRIVE?
	JP	NC,WRITEHST		; JUMP IF SO, DIRECT SECTOR WRITE
	XOR	A			; 0 TO ACCUMULATOR
	LD	(READOP),A		; NOT A READ OPERATION
	LD	A,C			; WRITE TYPE IN C
	LD	(WRTYPE),A		; GET WRITE TYPE
	CP	WRUAL			; WRITE UNALLOCATED?
	JR	NZ,CHKUNA		; CHECK FOR UNALLOC IF NOT
	LD	A,BLKSIZ/128		; NEXT UNALLOC RECS
	LD	(UNACNT),A		; SET UNALLOCATED COUNT
	LD	A,(UDUNIT)		; DISK TO SEEK
	LD	(UNADSK),A		; UNADSK = SEKDSK
	LD	HL,(UDTRACK)		; TRACK TO SEEK
	LD	(UNATRK),HL		; UNATRK = SECTRK
	LD	A,(UDSECTR)		; SECTOR TO SEEK
	LD	(UNASEC),A		; UNASEC = SEKSEC
CHKUNA:
	LD	A,(UNACNT)		; GET UNALLOC REMAINING
	OR	A			; ANY REMAIN?
	JR	Z,ALLOC			; SKIP IF NOT
	DEC	A			; UNACNT = UNACNT-1
	LD	(UNACNT),A		; STORE IT BACK
	LD	A,(UDUNIT)		; SAME DISK?
	LD	HL,UNADSK		; PTR TO UNALLOCATED DISK
	CP	(HL)			; CURRENT DISK = UNADSK?
	JR	NZ,ALLOC		; SKIP IF NOT
	LD	HL,UNATRK		; PTR TO UNALLOCATED TRACK
	CALL	SEKTRKCMP		; CURRENT TRACK = UNATRK?
	JR	NZ,ALLOC		; SKIP IF NOT
	LD	A,(UDSECTR)		; SAME SECTOR?
	LD	HL,UNASEC		; PTR TO UNALLOCATED SECTOR
	CP	(HL)			; CURRENT SECTOR = UNASEC?
	JR	NZ,ALLOC		; SKIP IF NOT
	INC	(HL)			; UNASEC = UNASEC+1
	LD	A,(HL)			; END OF TRACK?
	CP	CPMSPT			; COUNT CP/M SECTORS
	JR	C,NOOVF			; SKIP IF NO OVERFLOW
	LD	(HL),0			; UNASEC = 0
	LD	HL,(UNATRK)		; GET TRACK
	INC	HL			; UNATRK = UNATRK+1
	LD	(UNATRK),HL		; STORE TRACK
NOOVF:
	XOR	A			; 0 TO ACCUMULATOR
	LD	(RSFLAG),A		; RSFLAG = 0
	JR	RWOPER			; TO PERFORM THE WRITE
ALLOC:
	XOR	A			; 0 TO ACCUM
	LD	(UNACNT),A		; UNACNT = 0
	INC	A			; 1 TO ACCUM
	LD	(RSFLAG),A		; RSFLAG = 1
RWOPER:
	XOR	A			; ZERO TO ACCUM
	LD	(ERFLAG),A		; NO ERRORS (YET)
	LD	A,(UDSECTR)		; COMPUTE HOST SECTOR
;
	REPT	SECSHF
	SRL	A			; A = A * 2
	ENDM
;
	LD	(SEKHST),A		; HOST SECTOR TO SEEK
	LD	HL,HSTACT		; HOST ACTIVE FLAG
	LD	A,(HL)			; GET FLAG
	LD	(HL),1			; ALWAYS BECOMES 1
	OR	A			; WAS IT ALREADY?
	JR	Z,FILHST		; FILL HOST IF NOT
	LD	A,(UDUNIT)		; GET DRIVE
	LD	HL,HSTDSK		; SAME DISK?
	CP	(HL)			; CURRENT DISK = HSTDSK?
	JR	NZ,NOMATCH		; JUMP IF NOT
	LD	HL,HSTTRK		; PTR TO TRACK
	CALL	SEKTRKCMP		; CURRENT TRACK = HSTTRK?
	JR	NZ,NOMATCH		; JUMP IF NOT
	LD	A,(SEKHST)		; GET SECTOR
	LD	HL,HSTSEC		; PTR TO SECTOR
	CP	(HL)			; SAME SECTOR?
	JR	Z,MATCH			; SKIP IF MATCH
NOMATCH:
	LD	A,(HSTWRT)		; GET HOST WRITTEN FLAG
	OR	A			; WRITTEN?
	CALL	NZ,WRITEHST		; CLEAR HOST BUFF
FILHST:
	LD	A,(UDUNIT)		; GET DISK NUMBER
	LD	(HSTDSK),A		; STORE DEBLOCKING DISK
	LD	HL,(UDTRACK)		; GET TRACK
	LD	(HSTTRK),HL		; STORE IT
	LD	A,(SEKHST)		; GET SECTOR
	LD	(HSTSEC),A		; STORE IT
	LD	A,(RSFLAG)		; GET NEED TO READ FLAG
	OR	A			; NEED TO READ?
	CALL	NZ,READHST		; YES, IF 1
	XOR	A			; 0 TO ACCUM
	LD	(HSTWRT),A		; NO PENDING WRITE
MATCH:
	LD	A,(UDSECTR)		; MASK BUFFER NUMBER
	AND	SECMSK			; LEAST SIGNIF BITS
	LD	L,A			; READY TO SHIFT
	LD	H,0			; DOUBLE COUNT
	ADD	HL,HL			; SHIFT
	ADD	HL,HL			;  HL
	ADD	HL,HL			;   LEFT
	ADD	HL,HL			;    SEVEN
	ADD	HL,HL			;     TIMES
	ADD	HL,HL			;      CURRENT
	ADD	HL,HL			;       SECTOR
	LD	DE,HSTBUF		; PTR TO DEBLOCKING BUFFER
	ADD	HL,DE			; HL = HOST ADDRESS
	LD	DE,(UDSECBF)		; GET/PUT CP/M DATA
	LD	BC,128			; LENGTH OF MOVE
	LD	A,(READOP)		; WHICH WAY?
	OR	A			; WAS IT A READ
	JR	NZ,RWMOVE		; SKIP IF READ
	LD	A,1			; SET WRITE
	LD	(HSTWRT),A		; HSTWRT = 1
	EX	DE,HL			; DE = DESTIN, HL = SOURCE
RWMOVE:
	LDIR				; MOVE SECTOR
	LD	A,(WRTYPE)		; WRITE TYPE
	CP	WRDIR			; TO DIRECTORY?
	LD	A,(ERFLAG)		; IN CASE OF ERRORS
	RET	NZ			; NO FURTHER PROCESSING
	OR	A			; ERRORS?
	RET	NZ			; SKIP IF SO
	LD	(HSTWRT),A		; BUFFER WRITTEN
	CALL	WRITEHST		; WRITE SECTOR
	LD	A,(ERFLAG)		; GET ANY ERRORS
	RET				; EXIT
;
; *****
; ***** COMPARE TRACK WITH CURRENT TRACK
; *****
;
SEKTRKCMP:
	EX	DE,HL			; TRACK INTO DE
	LD	HL,UDTRACK		; PTR TO CURRENT TRACK
	LD	A,(DE)			; GET LSB TRACK TO CHECK
	CP	(HL)			; SAME?
	RET	NZ			; RETURN IF NOT
	INC	DE			; PT TO MSB CURRENT TRACK
	INC	HL			; PT TO MSB TRACK TO CHECK
	LD	A,(DE)			; GET MSB
	CP	(HL)			; SETS FLAGS
	RET				; EXIT
;
; *****
; ***** DISK SECTOR I/O
; *****
;
READHST:
	LD	DE,OFSTLOG		; DISK LOGIN OFFSET
	CALL	CALVCTR			; GO DO IT
	LD	DE,OFSTRD		; DISK READ OFFSET
	JR	CALVCTR			; READ SECTOR
;
WRITEHST:
	LD	DE,OFSTLOG		; DISK LOGIN OFFSET
	CALL	CALVCTR			; GO DO IT
	LD	DE,OFSTWR		; DISK WRITE OFFSET, FALL THRU
;
; *****
; ***** CALCULATE DISK DRIVER JUMP
; *****
;
CALVCTR:
	LD	HL,(CURDPH)		; GET DISK PARAMETER HEADER
	JR	CALVC1			; DO DISK OPERATION
;
; *****
; ***** CALCULATE I/O BYTE JUMP
; *****
;
IOVECTR:
	LD	B,A			; PUT BITS TO ROTATE RIGHT INTO B
	OR	A			; CHECK TO SEE IT ROTATION WAS 0
	LD	A,(IOBYTE)		; GET I/O BYTE
	JR	Z,I20			; IF ROTATION IS 0, DON'T ROTATE
I10:
	RRA				; ROTATE RIGHT
	RRA				;  TWICE
	DJNZ	I10			; B TIMES
I20:
	AND	X'03'			; REMOVE EXTRANEOUS BITS
	RLA				; TIMES 2
	LD	D,0			; ZERO D
	LD	E,A			; OFFSET INTO E
CALVC1:
	ADD	HL,DE			; ADD IT TO THE TABLE BASE ADDRESS
	LD	E,(HL)			; GET LOW BYTE
	INC	HL			; INCREMENT
	LD	D,(HL)			; GET HIGH BYTE
	EX	DE,HL			; PUT VECTOR INTO HL
	JP	(HL)			; JUMP TO IT
;
; *****
; ***** PRINT A MESSAGE AT REG. HL AND TERMINATED BY X'00'
; *****
;
PRMSG:
	LD	A,(HL)			; GET BYTE TO DISPLAY
	OR	A			; WAS IT 0
	RET	Z			; EXIT IF SO
	LD	C,A			; ELSE MOVE INTO C FOR OUTPUT ROUTINE
	INC	HL			; POINT TO NEXT BYTE
	PUSH	HL			; SAVE POINTER
	CALL	ICONOT			; DISPLAY BYTE
	POP	HL			; RESTORE POINTER
	JR	PRMSG			; DO IT AGAIN
;
; *****
; ***** CBIOS DATA
; *****
;
	DSEG
;
; *****
; ***** I/O BYTE VECTOR TABLES
; *****
;
TCONST:
	DEFW	TTYIST			; TTY: CONSOLE INPUT STATUS
	DEFW	CONST			; CRT: CONSOLE INPUT STATUS
	DEFW	IRDRST			; BAT: CONSOLE INPUT STATUS
	DEFW	IRDRST			; UC1: CONSOLE INPUT STATUS
TCONIN:
	DEFW	TTYIN			; TTY: CONSOLE INPUT DATA
	DEFW	KBIN			; CRT: CONSOLE INPUT DATA
	DEFW	IREADER			; BAT: CONSOLE INPUT DATA
	DEFW	IREADER			; UC1: CONSOLE INPUT DATA
TCONOT:
	DEFW	TTYOUT			; TTY: CONSOLE OUTPUT DATA
	DEFW	CRTOUT			; CRT: CONSOLE OUTPUT DATA
	DEFW	ILISTOT			; BAT: CONSOLE OUTPUT DATA
	DEFW	IPUNCH			; UC1: CONSOLE OUTPUT DATA
TLISTST:
	DEFW	TTYOST			; TTY: LIST OUTPUT STATUS
	DEFW	ERRST			; CRT: LIST OUTPUT STATUS
	DEFW	LISTST			; LPT: LIST OUTPUT STATUS
	DEFW	UL1ST			; UL1: LIST OUTPUT STATUS
TLISTOT:
	DEFW	TTYOUT			; TTY: LIST OUTPUT DATA
	DEFW	CRTOUT			; CRT: LIST OUTPUT DATA
	DEFW	LISTOT			; LPT: LIST OUTPUT DATA
	DEFW	UL1OUT			; UL1: LIST OUTPUT DATA
TREADER:
	DEFW	TTYIN			; TTY: READER INPUT DATA
	DEFW	PTRIN			; PTR: READER INPUT DATA
	DEFW	UR1IN			; UR1: READER INPUT DATA
	DEFW	UR2IN			; UR2: READER INPUT DATA
TRDRST:
	DEFW	TTYIST			; TTY: READER INPUT STATUS
	DEFW	PTRIST			; PTR: READER INPUT STATUS
	DEFW	UR1IST			; UR1: READER INPUT STATUS
	DEFW	UR2IST			; UR2: READER INPUT STATUS
TPUNCH:
	DEFW	TTYOUT			; TTY: PUNCH OUTPUT DATA
	DEFW	PTPOUT			; PTP: PUNCH OUTPUT DATA
	DEFW	UP1OUT			; UP1: PUNCH OUTPUT DATA
	DEFW	UP2OUT			; UP2: PUNCH OUTPUT DATA
;
; *****
; ***** ADDRESS TABLE OF DISK PARAMETER HEADERS IN DRIVE ORDER
; *****
; ***** TABLE FORMAT BYTE, WORD
; *****
; ***** BYTE = DEVICE CODE - DCCCAUUU
; *****                      |\_/|\_/
; *****                      | | | +--- UNIT/HEAD NUMBER
; *****                      | | +----- 1 = DRIVE ACTIVATED
; *****                      | +------- MPIO CONTROLLER BIT
; *****                      +--------- 1 = NEEDS DEBLOCKING
; *****
; ***** WORD = DISK PARAMETER HEADER ADDRESS
; *****
;
DPHTBL:
	DEFB	X'18'			; NONBLOCKED/EXT CTLR 1/UNIT 0
	DEFW	DPHFP0			; DRIVE A:
	DEFB	X'19'			; NONBLOCKED/EXT CTLR 1/UNIT 1
	DEFW	DPHFP1			; DRIVE B:
	DEFB	X'28'			; NONBLOCKED/EXT CTLR 2/UNIT 0
	DEFW	DPHFP2			; DRIVE C:
	DEFB	X'29'			; NONBLOCKED/EXT CTLR 2/UNIT 1
	DEFW	DPHFP3			; DRIVE D:
	DEFB	X'C8'			; BLOCKED/EXT CTLR 3/HEAD 0
	DEFW	DPHD0			; DRIVE E:
	DEFB	X'C9'			; BLOCKED/EXT CTLR 3/HEAD 1
	DEFW	DPHD1			; DRIVE F:
	DEFB	X'CA'			; BLOCKED/EXT CTLR 3/HEAD 2
	DEFW	DPHD2			; DRIVE G:
	DEFB	X'CB'			; BLOCKED/EXT CTLR 3/HEAD 3
	DEFW	DPHD3			; DRIVE H:
	DEFB	X'CC'			; BLOCKED/EXT CTLR 3/HEAD 4
	DEFW	DPHD4			; DRIVE I:
	DEFB	X'18'			; NONBLOCKED/EXT CTLR 1/UNIT 0
	DEFW	DPHFP2			; DRIVE J:
	DEFB	X'19'			; NONBLOCKED/EXT CTLR 1/UNIT 1
	DEFW	DPHFP3			; DRIVE K:
	DEFB	X'00'			; UNDEFINED
	DEFW	X'0000'			; DRIVE L:
	DEFB	X'08'			; NONBLOCKED/INT CTLR/UNIT 0
	DEFW	DPHM1			; DRIVE M:
	DEFB	X'09'			; NONBLOCKED/INT CTRL/UNIT 1
	DEFW	DPHM2			; DRIVE N:
	DEFB	X'00'			; UNDEFINED
	DEFW	X'0000'			; DRIVE O:
	DEFB	X'00'			; UNDEFINED
	DEFW	X'0000'			; DRIVE P:
;
; *****
; ***** PRINT THIS ON FAILED WARM BOOT
; *****
;
BOOTMSG:
	DEFB	CR,LF			; ERROR MSG FOR FAILED WARM BOOT
	DEFB	'...crash'
	DEFB	BEL
	DEFB	0
;
UDUNIT:
	DEFB	0			; UNIT NUMBER
UDTRACK:
	DEFW	0			; TRACK NUMBER
UDSECTR:
	DEFB	0			; SECTOR NUMBER
CURDPH:
	DEFW	0			; POINTER TO CURRENT DPH
DRVTYP:
	DEFB	0			; STORAGE FOR DRIVER TYPE
UDSECBF:
	DEFW	0			; POINTER TO SECTOR BUFFER ADDRESS
HSTDSK:
	DEFB	0			; HOST DISK NUMBER
HSTTRK:
	DEFW	0			; HOST TRACK NUMBER
HSTSEC:
	DEFB	0			; HOST SECTOR NUMBER
SEKHST:
	DEFB	0			; SEEK SHR SECSHF
HSTACT:
	DEFB	0			; HOST ACTIVE FLAG
HSTWRT:
	DEFB	0			; HOST WRITTEN FLAG
UNACNT:
	DEFB	0			; UNALLOC REC CNT
UNADSK:
	DEFB	0			; LAST UNALLOC DISK
UNATRK:
	DEFW	0			; LAST UNALLOC TRACK
UNASEC:
	DEFB	0			; LAST UNALLOC SECTOR
ERFLAG:
	DEFB	0			; ERROR REPORTING
RSFLAG:
	DEFB	0			; READ SECTOR FLAG
READOP:
	DEFB	0			; 1 IF READ OPERATION
WRTYPE:
	DEFB	0			; WRITE OPERATION TYPE
HSTBUF:
	DEFS	HSTSIZ			; HOST BUFFER
DIRBF:
	DEFS	128			; DIRECTORY BUFFER
;
	END
