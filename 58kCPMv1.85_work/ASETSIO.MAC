; ADS SERIAL PORT INITIALIZER
; TOM DE LELLIS
;
	.MAIN.::			; PLINK NEEDS THIS
;
	.Z80
	CSEG
;
BDOS	EQU	X'0005'			; CP/M BDOS CALL LOCATION
;
SIOTRK	EQU	X'00'			; LOCATION OF SIO DEFAULTS
SIOSEC	EQU	X'04'			; PHYSICAL SECTOR
;
SIOBAS	EQU	X'0080'+X'0000'		; SIO TABLE BASE = DMA+OFFSET
SIOTABS	EQU	X'FF80'			; BIOS ADDRESS OF SIO TABLE
;
CMDBYT	EQU	X'37'			; COMMAND BYTE FOR ALL PCI'S
;
SIO1MOD	EQU	X'C2'			; SIO1 MODE PORT
SIO1CMD	EQU	X'C3'			; SIO1 COMMAND PORT
;
SIO2MOD	EQU	X'C6'			; SIO2 MODE PORT
SIO2CMD	EQU	X'C7'			; SIO2 COMMAND PORT
;
SIO3MOD	EQU	X'A2'			; SIO3 MODE PORT
SIO3CMD	EQU	X'A3'			; SIO3 COMMAND PORT
;
SIO4MOD	EQU	X'A6'			; SIO4 MODE PORT
SIO4CMD	EQU	X'A7'			; SIO4 COMMAND PORT
;
MAXFLDS	EQU	15			; NUMBER OF FIELDS - 1
;
; START HERE!
;
	JP	START			; SKIP THIS STUFF
;
	DEFB	12
	DEFB	'ADS Serial Port Initializer VERSION 1.1',13,10
	DEFB	'Last update: 10/13/84 1:58AM',13,10
	DEFB	10
	DEFB	'Please report problems and suggestions',13,10
	DEFB	26
;
START:	CALL	GETSET			; GET PREVIOUS SETUP
;
	LD	DE,TITLE		; GET STARTUP MESSAGE
	CALL	PRMSG			; PRINT IT
;
	LD	B,MAXFLDS		; MAX NUMBER OF FIELDS
LIST:	LD	A,B			; PUT IT INTO A
	PUSH	BC			; SAVE COUNTER
	CALL	SHOWF			; SHOW FIELD VALUE
	POP	BC			; RESTORE COUNTER
	DJNZ	LIST			; LOOP UNTIL ALL FIELDS ARE SHOWN
	XOR	A			; ZERO A
	CALL	SHOWF			; PRINT FIRST FIELD
;
SELOP:	CALL	SHOWP			; PRINT A POINTER
	CALL	SHOWF			; PRINT THE FIELD VALUE
SEL10:	CALL	GETKEY			; GET A COMMAND
	CP	X'1A'			; WAS IT UP-ARROW KEY?
	JP	Z,UP			; IF SO, THEN MOVE POINTER UP
	CP	X'0C'			; WAS IT DOWN-ARROW
	JP	Z,DOWN			; IF SO, THEN MOVE POINTER DOWN
	CP	X'17'			; WAS IT LEFT ARROW
	JP	Z,DECR			; IF SO, DECREMENT FIELD
	CP	X'0B'			; WAS IT RIGHT ARROW
	JP	Z,INCR			; HMM, IF NOT THEN GET ANOTHER KEY
	CP	'M'			; SAVE TO PCI?
	CALL	Z,SETM			; IF SO, SETSIO
	CP	'D'			; SAVE TO DISK?
	CALL	Z,SETD			; IF SO, SET SIO AND SAVE IT
	CP	'1'			; COMPARE TO '1'
	JR	C,SEL10			; IS < 1 IGNORE
	CP	'4'+X'01'		; COMPARE TO '4'
	JR	NC,SEL10		; IF > 4 THEN IGNORE
	JP	FASTJP			; MUST BE FAST JUMP COMMAND
;
INCR:	LD	A,(WHERE)		; GET WHERE WE ARE
	SLA	A			; TIMES 2
	LD	HL,SIOTAB		; GET START OF SIOTABLE
	LD	D,0			; ZERO D
	LD	E,A			; PUT OFFSET INTO E
	ADD	HL,DE			; ADD OFFSET TO TABLE ADDRESS
	LD	A,(UPLIM)		; GET UPPER LIMIT WE CAN INCREMENT
	LD	C,A			; PUT IT INTO C
	LD	A,(HL)			; GET WHAT VALUE WE HAVE NOW
	CP	C			; IS IT WITHIN LIMITS
	JP	NC,SELOP		; IF NOT, THEN IGNORE THIS COMMAND
	INC	A			; ELSE INCREMENT VALUE
	LD	(HL),A			; STORE IT
	LD	DE,WIPE			; GET CLEAR
	CALL	PRMSG			; CLEAR PROMPT LINE
	JP	SELOP			; GET A NEW COMMAND
;
DECR:	LD	A,(WHERE)		; GET WHERE WE ARE
	SLA	A			; TIMES 2
	LD	HL,SIOTAB		; GET START OF SIO TABLE
	LD	D,0			; ZERO D
	LD	E,A			; OFFSET INTO E
	ADD	HL,DE			; ADD OFFSET TO BASE
	LD	A,(HL)			; GET FIELD VALUE
	OR	A			; IS IT 0
	JP	Z,SELOP			; IF SO, CANT DECREMENT, SO IGNORE
	DEC	A			; ELSE DECREMENT FIELD
	LD	(HL),A			; STORE IT
	LD	DE,WIPE			; GET CLEAR
	CALL	PRMSG			; CLEAR PROMPT LINE
	JP	SELOP			; GET A NEW COMMAND
;
UP:	LD	A,(WHERE)		; GET WHERE WE ARE
	OR	A			; IS IT 0
	JP	Z,SELOP			; IF SO, CANT MOVE POINTER UP
	CALL	NSHOWP			; ERASE POINTER NOW
	DEC	A			; ELSE MOVE POINTER UP
	LD	(WHERE),A		; STORE WHERE WE ARE NOW
	JP	SELOP			; GET NEW COMMAND
;
DOWN:	LD	A,(WHERE)		; GET WHERE WE ARE
	CP	MAXFLDS			; ARE WE PAST LAST FIELD
	JP	NC,SELOP		; IF SO, DO NOTHING
	CALL	NSHOWP			; ERASE POINTER NOW
	INC	A			; MOVE POINTER DOWN
	LD	(WHERE),A		; STORE WHERE WE ARE NOW
	JP	SELOP			; GET NEXT COMMAND
;
FASTJP:	CALL	NSHOWP			; ERASE OLD POINTER
	SUB	X'31'			; SUBTRACT 31
	SLA	A			; A TIMES 2
	SLA	A			; TIMES 2 AGAIN = TIMES 4
	LD	(WHERE),A		; STORE FAST JUMP
	JP	SELOP			; NEXT COMMAND
;
SETM:	CALL	GETSIO			; SET PCI
;
	LD	A,CMDBYT		; COMMAND
	OUT	(SIO1CMD),A		; SEND IT
	LD	A,(S1P)			; GET PROTOCOL FOR PORT 1
	OUT	(SIO1MOD),A		; SEND IT
	LD	A,(S1B)			; GET BAUD FOR PORT 1
	OUT	(SIO1MOD),A		; SEND IT
;
	LD	A,CMDBYT		; COMMAND
	OUT	(SIO2CMD),A		; SEND IT
	LD	A,(S2P)			; PROTOCOL
	OUT	(SIO2MOD),A		; SEND IT
	LD	A,(S2B)			; BAUD
	OUT	(SIO2MOD),A		; SEND IT TOO
;
	LD	A,CMDBYT		; COMMAND
	OUT	(SIO3CMD),A		; SEND IT
	LD	A,(S3P)			; GET PROTOCOL FOR PORT 1
	OUT	(SIO3MOD),A		; SEND IT
	LD	A,(S3B)			; GET BAUD FOR PORT 1
	OUT	(SIO3MOD),A		; SEND IT
;
	LD	A,CMDBYT		; COMMAND
	OUT	(SIO4CMD),A		; SEND IT
	LD	A,(S4P)			; PROTOCOL
	OUT	(SIO4MOD),A		; SEND IT
	LD	A,(S4B)			; BAUD
	OUT	(SIO4MOD),A		; SEND IT TOO
;
	LD	HL,SIOLST		; SOURCE TABLE ADDR
	LD	DE,SIOTABS		; DESTINATION TABLE ADDR
	LD	BC,4*3			; SIZE OF TABLE
	LDIR				; MOVE IT
;
	LD	DE,DONE			; GET SET MESSAGE
	CALL	PRMSG			; PRINT IT
	XOR	A			; CLEAR A
	RET				; EXIT
;
SETD:	CALL	GETSIO			; GET PROTOCOL FROM TABLES
	LD	DE,WHIDSK		; GET DISK PROMPT
	CALL	PRMSG			; PRINT IT
	CALL	GETKEY			; GET A KEY
	CP	'A'			; WAS IT A
	JR	C,SETD20		; IF <, SEE SETD20
	CP	'P'+1			; WAS IT > P
	JR	NC,SETD20		; IF SO ABORT THIS COMMAND
	CALL	PRCHR			; ELSE PRINT DISK SPECIFIER
	SUB	X'41'			; MAKE ADJUST FOR CBIOS CALL
	LD	C,A			; PUT DISK NUMBER INTO C
	LD	A,X'1B'			; SELECT DISK
	CALL	GOBIOS			; DO IT
	LD	A,H			; H INTO A
	OR	L			; L ALSO AND SEE OF 0 TOTAL
	JR	Z,SETD20		; IF SO JUMP
	LD	C,SIOTRK		; SET TRACK
	LD	A,X'1E'			; SETTRK
	CALL	GOBIOS			; DO IT
	LD	C,SIOSEC		; SET PHYSICAL SECTOR
	LD	A,X'21'			; SETSEC
	CALL	GOBIOS			; DO IT
	LD	BC,X'0080'		; DEFAULT SECTOR BUFFER
	LD	A,X'24'			; SET IT
	CALL	GOBIOS			; YES, SET IT
	LD	A,X'27'			; READ THE TRACK/SECTOR
	CALL	GOBIOS			; DO IT
	LD	A,CMDBYT		; COMMAND BTYE
	LD	(SIOBAS+X'00'),A	; STORE IT
	LD	(SIOBAS+X'03'),A	; STORE IT
	LD	(SIOBAS+X'06'),A	; STORE IT
	LD	(SIOBAS+X'09'),A	; STORE IT
	LD	A,(S1P)			; GET PROTOCOL FOR SIO1
	LD	(SIOBAS+X'01'),A	; STORE IT
	LD	A,(S1B)			; GET BAUD
	LD	(SIOBAS+X'02'),A	; STORE
	LD	A,(S2P)			; GET PROTOCOL FOR SIO2
	LD	(SIOBAS+X'04'),A	; STORE
	LD	A,(S2B)			; BAUD
	LD	(SIOBAS+X'05'),A	; STORE
	LD	A,(S3P)			; GET PROTOCOL FOR SIO3
	LD	(SIOBAS+X'07'),A	; STORE IT
	LD	A,(S3B)			; GET BAUD
	LD	(SIOBAS+X'08'),A	; STORE
	LD	A,(S4P)			; GET PROTOCOL FOR SIO4
	LD	(SIOBAS+X'0A'),A	; STORE
	LD	A,(S4B)			; BAUD
	LD	(SIOBAS+X'0B'),A	; STORE
	LD	A,X'2A'			; WRITE BACK THE CHANGED SECTOR
	CALL	GOBIOS			; DO IT
	LD	DE,DSKMSG		; GET WE DID IT MSG
	CALL	PRMSG			; PRINT IT
	XOR	A			; CLEAR A
	RET				; EXIT
SETD20:	LD	DE,ABDSKM		; ABORT DISK SAVE MSG
	CALL	PRMSG			; PRINT IT
	XOR	A			; CLEAR A
	RET				; EXIT TOO
;
EXIT:	CALL	NSHOWP			; TURN OFF POINTER
	LD	DE,ABMSG		; GET EXIT MSG
	CALL	PRMSG			; PRINT IT
	JP	0			; WARM BOOT TO CP/M
;
GETSIO:	LD	IX,SIOTAB		; START OF SIO TABLE
;
	LD	HL,WORDS		; POINT TO START OF WORD TABLE
	LD	A,(IX+X'02')		; GET WORD SETTING
	LD	D,0			; ZERO 0
	LD	E,A			; PUT OFSETT INTO E
	ADD	HL,DE			; ADD OFFSET
	LD	A,(HL)			; GET WORD
	PUSH	AF			; SAVE IT
;
	LD	HL,PARITYS		; POINT TO START OF PARITY TABLE
	LD	A,(IX+X'04')		; GET PARITY SETTING
	LD	E,A			; INTO E IT GOES
	ADD	HL,DE			; ADD OFFSET TO BASE
	LD	A,(HL)			; GET PARITY
	LD	C,A			; STICK IT INTO C
	POP	AF			; RESTORE
	OR	C			; MERGE WORD AND PARITY
	PUSH	AF			; STORE RESULT
;
	LD	HL,STOPS		; POINT TO STOP BIT TABLE
	LD	A,(IX+X'06')		; GET STOP BIT SETTING
	LD	E,A			; PUT IT INTO E
	ADD	HL,DE			; ADD OFFSET
	LD	A,(HL)			; GET STOP BIT VALUE
	LD	C,A			; STICK IT INTO C
	POP	AF			; RESTORE PREVIOUS MERGER
	OR	C			; OR IN STOP BITS
	LD	(S1P),A			; STORE FINAL PRODUCT
;
	LD	HL,BAUDS		; POINT TO BAUD RATE
	LD	A,(IX+X'00')		; GET OFFSET
	LD	E,A			; PUT IT INTO E
	ADD	HL,DE			; ADD TO BASE
	LD	A,(HL)			; GET BAUD RATE VALUE
	LD	(S1B),A			; STORE FINAL PRODUCT
;
	LD	HL,WORDS		; POINT TO START OF WORD TABLE
	LD	A,(IX+X'0A')		; GET WORD SETTING
	LD	E,A			; PUT OFSETT INTO E
	ADD	HL,DE			; ADD OFFSET
	LD	A,(HL)			; GET WORD
	PUSH	AF			; SAVE IT
;
	LD	HL,PARITYS		; POINT TO START OF PARITY TABLE
	LD	A,(IX+X'0C')		; GET PARITY SETTING
	LD	E,A			; INTO E IT GOES
	ADD	HL,DE			; ADD OFFSET TO BASE
	LD	A,(HL)			; GET PARITY
	LD	C,A			; STICK IT INTO C
	POP	AF			; RESTORE
	OR	C			; MERGE WORD AND PARITY
	PUSH	AF			; STORE RESULT
;
	LD	HL,STOPS		; POINT TO STOP BIT TABLE
	LD	A,(IX+X'0E')		; GET STOP BIT SETTING
	LD	E,A			; PUT IT INTO E
	ADD	HL,DE			; ADD OFFSET
	LD	A,(HL)			; GET STOP BIT VALUE
	LD	C,A			; STICK IT INTO C
	POP	AF			; RESTORE PREVIOUS MERGER
	OR	C			; OR IN STOP BITS
	LD	(S2P),A			; STORE FINAL RESULT
;
	LD	HL,BAUDS		; POINT TO BAUD RATE
	LD	A,(IX+X'08')		; GET OFFSET
	LD	E,A			; PUT IT INTO E
	ADD	HL,DE			; ADD TO BASE
	LD	A,(HL)			; GET BAUD RATE VALUE
	LD	(S2B),A			; STORE RESULT
;
	LD	HL,WORDS		; POINT TO START OF WORD TABLE
	LD	A,(IX+X'12')		; GET WORD SETTING
	LD	D,0			; ZERO 0
	LD	E,A			; PUT OFSETT INTO E
	ADD	HL,DE			; ADD OFFSET
	LD	A,(HL)			; GET WORD
	PUSH	AF			; SAVE IT
;
	LD	HL,PARITYS		; POINT TO START OF PARITY TABLE
	LD	A,(IX+X'14')		; GET PARITY SETTING
	LD	E,A			; INTO E IT GOES
	ADD	HL,DE			; ADD OFFSET TO BASE
	LD	A,(HL)			; GET PARITY
	LD	C,A			; STICK IT INTO C
	POP	AF			; RESTORE
	OR	C			; MERGE WORD AND PARITY
	PUSH	AF			; STORE RESULT
;
	LD	HL,STOPS		; POINT TO STOP BIT TABLE
	LD	A,(IX+X'16')		; GET STOP BIT SETTING
	LD	E,A			; PUT IT INTO E
	ADD	HL,DE			; ADD OFFSET
	LD	A,(HL)			; GET STOP BIT VALUE
	LD	C,A			; STICK IT INTO C
	POP	AF			; RESTORE PREVIOUS MERGER
	OR	C			; OR IN STOP BITS
	LD	(S3P),A			; STORE FINAL PRODUCT
;
	LD	HL,BAUDS		; POINT TO BAUD RATE
	LD	A,(IX+X'10')		; GET OFFSET
	LD	E,A			; PUT IT INTO E
	ADD	HL,DE			; ADD TO BASE
	LD	A,(HL)			; GET BAUD RATE VALUE
	LD	(S3B),A			; STORE FINAL PRODUCT
;
	LD	HL,WORDS		; POINT TO START OF WORD TABLE
	LD	A,(IX+X'1A')		; GET WORD SETTING
	LD	E,A			; PUT OFSETT INTO E
	ADD	HL,DE			; ADD OFFSET
	LD	A,(HL)			; GET WORD
	PUSH	AF			; SAVE IT
;
	LD	HL,PARITYS		; POINT TO START OF PARITY TABLE
	LD	A,(IX+X'1C')		; GET PARITY SETTING
	LD	E,A			; INTO E IT GOES
	ADD	HL,DE			; ADD OFFSET TO BASE
	LD	A,(HL)			; GET PARITY
	LD	C,A			; STICK IT INTO C
	POP	AF			; RESTORE
	OR	C			; MERGE WORD AND PARITY
	PUSH	AF			; STORE RESULT
;
	LD	HL,STOPS		; POINT TO STOP BIT TABLE
	LD	A,(IX+X'1E')		; GET STOP BIT SETTING
	LD	E,A			; PUT IT INTO E
	ADD	HL,DE			; ADD OFFSET
	LD	A,(HL)			; GET STOP BIT VALUE
	LD	C,A			; STICK IT INTO C
	POP	AF			; RESTORE PREVIOUS MERGER
	OR	C			; OR IN STOP BITS
	LD	(S4P),A			; STORE FINAL RESULT
;
	LD	HL,BAUDS		; POINT TO BAUD RATE
	LD	A,(IX+X'18')		; GET OFFSET
	LD	E,A			; PUT IT INTO E
	ADD	HL,DE			; ADD TO BASE
	LD	A,(HL)			; GET BAUD RATE VALUE
	LD	(S4B),A			; STORE RESULT
;
	RET				; EXIT
;
SHOWP:	LD	A,(WHERE)		; GET WHERE POINTER IS
	CALL	ATIM10			; MULTIPLY BY 10
	EX	DE,HL			; PUT RESULT INTO DE
	LD	IX,PLOC			; POINT TO BASE OF POINT TABLE
	ADD	IX,DE			; ADD OFFSET
	PUSH	IX			; PUSH RESULT
	POP	DE			; POP INTO DE
	CALL	PRMSG			; PRINT THE POINT
	LD	DE,PTR			; GET THE POINTER
	CALL	PRMSG			; PRINT IT
	RET				; EXIT
;
NSHOWP:	PUSH	AF			; SAVE A
	LD	A,(WHERE)		; GET WHERE POINTER IS
	CALL	ATIM10			; MULTIPLY BY 10
	EX	DE,HL			; PUT RESULT INTO DE
	LD	IX,PLOC			; POINT TO BASE
	ADD	IX,DE			; ADD OFFSET
	PUSH	IX			; PUSH RESULT
	POP	DE			; POP INTO DE
	CALL	PRMSG			; POINT
	LD	DE,NPTR			; LOAD THE NOT POINTER
	CALL	PRMSG			; PRINT IT
	POP	AF			; RESTORE A
	RET				; EXIT
;
SHOWF:	CALL	ATIM10			; MULT A TIMES 10 INTO HL
	EX	DE,HL			; PUT RESULT INTO DE
	LD	IX,PLOC			; POINT BASE
	ADD	IX,DE			; ADD OFFSET
	LD	BC,5			; GET A 5
	ADD	IX,BC			; ADD 5 MORE TO RESULT
	PUSH	IX			; PUSH IX
	POP	DE			; POP INTO DE
	CALL	PRMSG			; POINT TO FIELD
;
	LD	IX,BAUD			; SET IT TO BASE OF BAUD DISPLAYS
	LD	BC,(SIO1B)		; GET VALUE OF BAUD
	OR	A			; ARE WE IN FIELD 0
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,WORD			; LOAD WORD POINTER
	LD	BC,(SIO1W)		; LOAD WORD VALUE
	DEC	A			; ARE WE IN THE WORD FIELD
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,PARITY		; LOAD PARITY DISPLAY BASE
	LD	BC,(SIO1P)		; LOAD PARITY VALUE
	DEC	A			; ARE WE IN THE PARITY FIELD
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,STOP			; LOAD STOP DISPLAY BASE
	LD	BC,(SIO1S)		; LOAD STOP VALUE
	DEC	A			; ARE WE IN THE STOP FIELD
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,BAUD			; HMM, LOAD BAUD POINTER
	LD	BC,(SIO2B)		; LOAD BAUD VALUE FOR SIO2 THIS TIME
	DEC	A			; RIGHT FIELD?
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,WORD			; WORD DISPLAY BASE
	LD	BC,(SIO2W)		; WORD VALUE
	DEC	A			; RIGHT FIELD?
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,PARITY		; LOAD PARITY DISPLAY BASE
	LD	BC,(SIO2P)		; LOAD PARITY VALUE
	DEC	A			; RIGHT FIELD?
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,STOP			; MUST BE STOP FIELD THEN
	LD	BC,(SIO2S)		; GET STOP VALUE FOR SIO2
	DEC	A			; RIGHT FIELD?
	JP	Z,SHOW10
;
	LD	IX,BAUD			; SET IT TO BASE OF BAUD DISPLAYS
	LD	BC,(SIO3B)		; GET VALUE OF BAUD
	DEC	A			; RIGHT FIELD?
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,WORD			; LOAD WORD POINTER
	LD	BC,(SIO3W)		; LOAD WORD VALUE
	DEC	A			; ARE WE IN THE WORD FIELD
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,PARITY		; LOAD PARITY DISPLAY BASE
	LD	BC,(SIO3P)		; LOAD PARITY VALUE
	DEC	A			; ARE WE IN THE PARITY FIELD
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,STOP			; LOAD STOP DISPLAY BASE
	LD	BC,(SIO3S)		; LOAD STOP VALUE
	DEC	A			; ARE WE IN THE STOP FIELD
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,BAUD			; HMM, LOAD BAUD POINTER
	LD	BC,(SIO4B)		; LOAD BAUD VALUE FOR SIO4 THIS TIME
	DEC	A			; RIGHT FIELD?
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,WORD			; WORD DISPLAY BASE
	LD	BC,(SIO4W)		; WORD VALUE
	DEC	A			; RIGHT FIELD?
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,PARITY		; LOAD PARITY DISPLAY BASE
	LD	BC,(SIO4P)		; LOAD PARITY VALUE
	DEC	A			; RIGHT FIELD?
	JP	Z,SHOW10		; IF SO, SEE SHOW10
;
	LD	IX,STOP			; MUST BE STOP FIELD THEN
	LD	BC,(SIO4S)		; GET STOP VALUE FOR SIO4
;
SHOW10:	LD	A,(IX+X'00')		; GET UPPER BOUNDS OF VALUES
	LD	(UPLIM),A		; STORE IT
	INC	IX			; POINT TO START OF DISPLAY TABLE
	LD	A,C			; GET OFFSET
	LD	H,0			; ZERO H
	LD	L,C			; MOVE OFFSET TO L
	ADD	HL,HL			; TIMES 2
	LD	B,H			; SAVE THIS
	LD	C,L			; INTO BC
	ADD	HL,HL			; TIMES 2 AGAIN = TIMES 4
	ADD	HL,BC			; PLUS THE TIMES 2 = TIMES 6
	EX	DE,HL			; PUT RESULT INTO DE
	ADD	IX,DE			; ADD IT TO DISPLAY BASE
	PUSH	IX			; PUSH RESULT
	POP	DE			; POP INTO DE
	CALL	PRMSG			; PRINT THE FIELD
	RET				; EXIT
;
ATIM10:	PUSH	AF			; SAVE AF
	LD	H,0			; ZERO H
	LD	L,A			; PUT VALUE TO MULT INTO L
	ADD	HL,HL			; TIMES 2
	ADD	HL,HL			; TIMES 2 AGAIN = TIMES 4
	ADD	A,L			; PLUS ORIGINAL = TIMES 5
	LD	L,A			; TIMES 5 BACK TO L
	ADD	HL,HL			; TIMES 2 AGAIN = TIMES 10
	POP	AF			; RESTORE A
	RET				; EXIT
;
GETSET:	IN	A,(SIO1CMD)		; READ COMMAND REG TO RESET MODE PTRS
	CP	CMDBYT			; HAS SIO1 BEEN SET EVER?
	JP	NZ,GETS10		; IF NOT, GO WITH DEFAULTS
	IN	A,(SIO1MOD)		; GET MODE REG 1
	LD	C,A			; SAVE IT
	IN	A,(SIO1MOD)		; GET BAUD VALUE
	OR	A			; CHECK IF SET BEFORE
	JR	Z,GETS01		; IF NOT, KEEP DEFAULT
	AND	X'0F'			; KEEP ONLY BAUD VALUE
	LD	(SIO1B),A		; STORE VALUE
GETS01:	LD	A,C			; NOW SPLIT PROTOCOL VALUES
	SRL	A			; SHIFT
	SRL	A			; INTO POSITION
	LD	C,A			; STORE THIS RESULT
	AND	X'03'			; KEEP WORD
	LD	(SIO1W),A		; STORE IT
	LD	A,C			; RECALL LAST RESULTS
	SRL	A			; SHIFT
	SRL	A			; AGAIN
	LD	C,A			; STORE
	AND	X'01'			; CHECK FOR PARITY ENABLED OR NOT
	JR	Z,GETS05		; IF NOT, STICK TO DEFAULT
	LD	A,C			; GET ORIGINAL PARITY BITS
	AND	X'03'			; KEEP RELEVANT BITS
	BIT	1,A			; CHECK FOR EVEN OR ODD PARITY
	JR	Z,GETS04		; IF ODD PARITY, STORE NOW
	AND	X'02'			; CLEAR PARITY ENA DSA
GETS04:	LD	(SIO1P),A		; STORE IT
GETS05:	LD	A,C			; RECALL LAST RESULT
	SRL	A			; SHIFT
	SRL	A			; AND SHIFT ONCE MORE
	AND	X'03'			; KEEP ONLY STOP BITS
	DEC	A			; REMOVE INVALID SETTING
	LD	(SIO1S),A		; STORE THEM
;
GETS10:	IN	A,(SIO2CMD)		; READ COMMAND REG TO RESET MODE PTRS
	CP	CMDBYT			; HAS SIO2 BEEN SET EVER?
	JP	NZ,GETS20		; IF NOT, GO WITH DEFAULTS
	IN	A,(SIO2MOD)		; GET MODE REG 1
	LD	C,A			; SAVE IT
	IN	A,(SIO2MOD)		; GET BAUD VALUE
	OR	A			; CHECK IF SET BEFORE
	JR	Z,GETS11		; KEEP DEFAULT IF NOT SET
	AND	X'0F'			; KEEP ONLY BAUD VALUE
	LD	(SIO2B),A		; STORE VALUE
GETS11:	LD	A,C			; NOW SPLIT PROTOCOL VALUES
	SRL	A			; SHIFT
	SRL	A			; INTO POSITION
	LD	C,A			; STORE THIS RESULT
	AND	X'03'			; KEEP WORD
	LD	(SIO2W),A		; STORE IT
	LD	A,C			; RECALL LAST RESULTS
	SRL	A			; SHIFT
	SRL	A			; AGAIN
	LD	C,A			; STORE
	AND	X'01'			; CHECK FOR PARITY ENABLED OR NOT
	JR	Z,GETS15		; IF NOT, STICK TO DEFAULT
	LD	A,C			; GET ORIGINAL PARITY BITS
	AND	X'03'			; KEEP RELEVANT BITS
	BIT	1,A			; CHECK FOR EVEN OR ODD PARITY
	JR	Z,GETS14		; IF ODD PARITY, STORE NOW
	AND	X'02'			; CLEAR PARITY ENA DSA
GETS14:	LD	(SIO2P),A		; STORE IT
GETS15:	LD	A,C			; RECALL LAST RESULT
	SRL	A			; SHIFT
	SRL	A			; AND SHIFT ONCE MORE
	AND	X'03'			; KEEP ONLY STOP BITS
	DEC	A			; REMOVE INVALID SETTING
	LD	(SIO2S),A		; STORE THEM
;
GETS20:	IN	A,(SIO3CMD)		; READ COMMAND REG TO RESET MODE PTRS
	CP	CMDBYT			; HAS SIO3 BEEN SET EVER?
	JP	NZ,GETS30		; IF NOT, GO WITH DEFAULTS
	IN	A,(SIO3MOD)		; GET MODE REG 1
	LD	C,A			; SAVE IT
	IN	A,(SIO3MOD)		; GET BAUD VALUE
	OR	A			; CHECK IF SET BEFORE
	JR	Z,GETS21		; KEEP DEFAULT IF NOT SET
	AND	X'0F'			; KEEP ONLY BAUD VALUE
	LD	(SIO3B),A		; STORE VALUE
GETS21:	LD	A,C			; NOW SPLIT PROTOCOL VALUES
	SRL	A			; SHIFT
	SRL	A			; INTO POSITION
	LD	C,A			; STORE THIS RESULT
	AND	X'03'			; KEEP WORD
	LD	(SIO3W),A		; STORE IT
	LD	A,C			; RECALL LAST RESULTS
	SRL	A			; SHIFT
	SRL	A			; AGAIN
	LD	C,A			; STORE
	AND	X'01'			; CHECK FOR PARITY ENABLED OR NOT
	JR	Z,GETS25		; IF NOT, STICK TO DEFAULT
	LD	A,C			; GET ORIGINAL PARITY BITS
	AND	X'03'			; KEEP RELEVANT BITS
	BIT	1,A			; CHECK FOR EVEN OR ODD PARITY
	JR	Z,GETS24		; IF ODD PARITY, STORE NOW
	AND	X'02'			; CLEAR PARITY ENA DSA
GETS24:	LD	(SIO3P),A		; STORE IT
GETS25:	LD	A,C			; RECALL LAST RESULT
	SRL	A			; SHIFT
	SRL	A			; AND SHIFT ONCE MORE
	AND	X'03'			; KEEP ONLY STOP BITS
	DEC	A			; REMOVE INVALID SETTING
	LD	(SIO3S),A		; STORE THEM
;
GETS30:	IN	A,(SIO4CMD)		; READ COMMAND REG TO RESET MODE PTRS
	CP	CMDBYT			; HAS SIO4 BEEN SET EVER?
	RET	NZ			; IF NOT, GO WITH DEFAULTS
	IN	A,(SIO4MOD)		; GET MODE REG 1
	LD	C,A			; SAVE IT
	IN	A,(SIO4MOD)		; GET BAUD VALUE
	OR	A			; CHECK IF SET BEFORE
	JR	Z,GETS31		; KEEP DEFAULT IF NOT SET
	AND	X'0F'			; KEEP ONLY BAUD VALUE
	LD	(SIO4B),A		; STORE VALUE
GETS31:	LD	A,C			; NOW SPLIT PROTOCOL VALUES
	SRL	A			; SHIFT
	SRL	A			; INTO POSITION
	LD	C,A			; STORE THIS RESULT
	AND	X'03'			; KEEP WORD
	LD	(SIO4W),A		; STORE IT
	LD	A,C			; RECALL LAST RESULTS
	SRL	A			; SHIFT
	SRL	A			; AGAIN
	LD	C,A			; STORE
	AND	X'01'			; CHECK FOR PARITY ENABLED OR NOT
	JR	Z,GETS35		; IF NOT, STICK TO DEFAULT
	LD	A,C			; GET ORIGINAL PARITY BITS
	AND	X'03'			; KEEP RELEVANT BITS
	BIT	1,A			; CHECK FOR EVEN OR ODD PARITY
	JR	Z,GETS34		; IF ODD PARITY, STORE NOW
	AND	X'02'			; CLEAR PARITY ENA DSA
GETS34:	LD	(SIO4P),A		; STORE IT
GETS35:	LD	A,C			; RECALL LAST RESULT
	SRL	A			; SHIFT
	SRL	A			; AND SHIFT ONCE MORE
	AND	X'03'			; KEEP ONLY STOP BITS
	DEC	A			; REMOVE INVALID SETTING
	LD	(SIO4S),A		; STORE THEM
;
	RET				; EXIT
;
GOBIOS:	PUSH	DE			; SAVE DE
	PUSH	AF			; SAVE AF FOR LATER
	LD	A,(2)			; GET BASE PAGE OF BIOS
	LD	H,A			; INTO H IT GOES
	LD	L,0			; ZERO L ASSUME EVEN BOUNDRY
	LD	D,0			; ZERO D
	POP	AF			; GET BIOS OFFSET
	LD	E,A			; INTO E
	ADD	HL,DE			; ADD IT TO BASE OF BIOS
	POP	DE			; RESTORE DE
	JP	(HL)			; GOTO BIOS FUNCTION
;
GETKEY:	PUSH	HL
	PUSH	DE
GET10:	LD	C,6
	LD	E,X'FF'
	CALL	BDOS
	OR	A
	JR	Z,GET10
	CP	X'60'
	JR	C,GET20
	SUB	X'20'
GET20:	POP	DE
	POP	HL
	CP	3
	JP	Z,EXIT
	RET
;
PRCHR:	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	C,6
	LD	E,A
	CALL	BDOS
	POP	AF
	POP	BC
	POP	DE
	POP	HL
	RET
;
PRMSG:	PUSH	HL
	PUSH	BC
	PUSH	AF
	EX	DE,HL
PRM10:	LD	A,(HL)
	OR	A
	JR	Z,PRM20
	LD	E,A
	LD	C,6
	PUSH	HL
	CALL	BDOS
	POP	HL
	INC	HL
	JR	PRM10
PRM20:	POP	AF
	POP	BC
	POP	HL
	RET
;
TITLE:	DEFB	12
	DEFB	27,'3'
	DEFB	'======== ADS Serial Port Initializer v1.1 '
	DEFB	'====================== Kontron ======',13,10
	DEFB	10
	DEFB	10
	DEFB	'      SIO 1',9,9,9,'      SIO 3',13,10
	DEFB	9,'Baud rate   =',9,9,9,'Baud rate   =',13,10
	DEFB	9,'Word length =',9,9,9,'Word length =',13,10
	DEFB	9,'Parity      =',9,9,9,'Parity      =',13,10
	DEFB	9,'Stop bits   =',9,9,9,'Stop bits   =',13,10
	DEFB	10
	DEFB	'      SIO 2',9,9,9,'      SIO 4',13,10
	DEFB	9,'Baud rate   =',9,9,9,'Baud rate   =',13,10
	DEFB	9,'Word length =',9,9,9,'Word length =',13,10
	DEFB	9,'Parity      =',9,9,9,'Parity      =',13,10
	DEFB	9,'Stop bits   =',9,9,9,'Stop bits   =',13,10
	DEFB	10
	DEFB	10
	DEFB	'<UP-ARROW> - Move pointer up',9,9,'      <M> - Save changes to memory',13,10
	DEFB	'<DN-ARROW> - Move pointer down',9,9,'      <D> - Save changes to disk',13,10
	DEFB	'<LT-ARROW> - Decrement value',9,9,' <CTRL-C> - Exit the program',13,10
	DEFB	'<RT-ARROW> - Increment value',9,9,'<1/2/3/4> - Fast jump to SIO field'
	DEFB	0
;
DONE:	DEFB	1
	DEFB	26
	DEFB	27,'K'
	DEFB	'Serial ports now initialized to current values'
	DEFB	0
;
ABMSG:	DEFB	1
	DEFB	26
	DEFB	27,'K'
	DEFB	'Exiting...'
	DEFB	27,'4'
	DEFB	0
;
WHIDSK:	DEFB	1
	DEFB	26
	DEFB	27,'K'
	DEFB	'Which drive do you want to save the current values to? (A..P) '
	DEFB	27,'4'
	DEFB	0
;
DSKMSG:	DEFB	1
	DEFB	26
	DEFB	27,'3'
	DEFB	27,'K'
	DEFB	'Current values for serial ports saved...'
	DEFB	0
;
ABDSKM:	DEFB	1
	DEFB	26
	DEFB	27,'3'
	DEFB	27,'K'
	DEFB	'Disk save ignored...'
	DEFB	0
;
WIPE:	DEFB	1
	DEFB	26
	DEFB	27,'K'
	DEFB	0
;
BAUD:	DEFB	15
	DEFB	'50   ',0
	DEFB	'75   ',0
	DEFB	'110  ',0
	DEFB	'134.5',0
	DEFB	'150  ',0
	DEFB	'300  ',0
	DEFB	'600  ',0
	DEFB	'1200 ',0
	DEFB	'1800 ',0
	DEFB	'2000 ',0
	DEFB	'2400 ',0
	DEFB	'3600 ',0
	DEFB	'4800 ',0
	DEFB	'7200 ',0
	DEFB	'9600 ',0
	DEFB	'19200',0
;
WORD:	DEFB	3
	DEFB	'5    ',0
	DEFB	'6    ',0
	DEFB	'7    ',0
	DEFB	'8    ',0
;
PARITY:	DEFB	2
	DEFB	'NONE ',0
	DEFB	'ODD  ',0
	DEFB	'EVEN ',0
;
STOP:	DEFB	2
	DEFB	'1    ',0
	DEFB    '1.5  ',0
	DEFB    '2    ',0
;
BAUDS:	DEFB	X'30',X'31',X'32',X'33',X'34',X'35',X'36',X'37'
	DEFB	X'38',X'39',X'3A',X'3B',X'3C',X'3D',X'3E',X'3F'
;
WORDS:	DEFB	X'02',X'06',X'0A',X'0E'
;
PARITYS:DEFB	X'00',X'10',X'30'
;
STOPS:	DEFB	X'40',X'80',X'C0'
;
PTR:	DEFB	'-->',0
NPTR:	DEFB	'   ',0
;
PLOC:	DEFB	27,'Y',4+32,4+32,0
	DEFB	27,'Y',4+32,22+32,0
	DEFB	27,'Y',5+32,4+32,0
	DEFB	27,'Y',5+32,22+32,0
	DEFB	27,'Y',6+32,4+32,0
	DEFB	27,'Y',6+32,22+32,0
	DEFB	27,'Y',7+32,4+32,0
	DEFB	27,'Y',7+32,22+32,0
;
	DEFB	27,'Y',10+32,4+32,0
	DEFB	27,'Y',10+32,22+32,0
	DEFB	27,'Y',11+32,4+32,0
	DEFB	27,'Y',11+32,22+32,0
	DEFB	27,'Y',12+32,4+32,0
	DEFB	27,'Y',12+32,22+32,0
	DEFB	27,'Y',13+32,4+32,0
	DEFB	27,'Y',13+32,22+32,0
;
	DEFB	27,'Y',4+32,36+32,0
	DEFB	27,'Y',4+32,54+32,0
	DEFB	27,'Y',5+32,36+32,0
	DEFB	27,'Y',5+32,54+32,0
	DEFB	27,'Y',6+32,36+32,0
	DEFB	27,'Y',6+32,54+32,0
	DEFB	27,'Y',7+32,36+32,0
	DEFB	27,'Y',7+32,54+32,0
;
	DEFB	27,'Y',10+32,36+32,0
	DEFB	27,'Y',10+32,54+32,0
	DEFB	27,'Y',11+32,36+32,0
	DEFB	27,'Y',11+32,54+32,0
	DEFB	27,'Y',12+32,36+32,0
	DEFB	27,'Y',12+32,54+32,0
	DEFB	27,'Y',13+32,36+32,0
	DEFB	27,'Y',13+32,54+32,0
;
SIOTAB:
SIO1B:	DEFW	5
SIO1W:	DEFW	3
SIO1P:	DEFW	0
SIO1Sº	DEFW	0
;
SIO2B:	DEFW	5
SIO2W:	DEFW	3
SIO2P:	DEFW	0
SIO2S:	DEFW	0
;
SIO3B:	DEFW	5
SIO3W:	DEFW	3
SIO3P:	DEFW	0
SIO3Sº	DEFW	0
;
SIO4B:	DEFW	5
SIO4W:	DEFW	3
SIO4P:	DEFW	0
SIO4S:	DEFW	0
;
SIOLST:
	DEFB	CMDBYT
S1P:	DEFS	1
S1B:	DEFS	1
;
	DEFB	CMDBYT
S2P:	DEFS	1
S2B:	DEFS	1
;
	DEFB	CMDBYT
S3P:	DEFS	1
S3B:	DEFS	1
;
	DEFB	CMDBYT
S4P:	DEFS	1
S4B:	DEFS	1
;
WHERE:	DEFB	0
;
UPLIM:	DEFS	1
;
	END
