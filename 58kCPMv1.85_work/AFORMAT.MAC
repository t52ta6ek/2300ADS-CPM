; ADS FLOPPY DISK FORMATTER
; TOM DE LELLIS
;
	.MAIN.::			; SOMETHING TO DO WITH PLINK
;
	.Z80
	CSEG
;
TPDF	EQU	77			; TRACKS PER DISK ON FLOPPY
;
RAMDSK1	EQU	'M'-X'41'		; RAM DISK 0 SPECIFIER
RAMDSK2	EQU	'N'-X'41'		; RAM DISK 1 SPECIFIER
;
BDOS	EQU	X'0005'			; BDOS CALL LOCATION
;
ORDY	EQU	X'02'			; OUTPUT READY ON DISK CONTROLER
CBUSY	EQU	X'10'			; CONTROLLER BUSY
IRDY	EQU	X'20'			; INPUT DATA READY
;
DCTLR1	EQU	X'D8'			; FLOPPY DISK CONTROL PORT
DDATA1	EQU	X'D9'			; FLOPPY DATA PORT
;
FMTCMD	EQU	X'91'			; FLOPPY FORMAT CMND CODE
VFYCMD	EQU	X'8D'			; FLOPPY VERIFY CMND CODE
STACMD	EQU	X'81'			; FLOPPY STATUS
;
MPIOBST	EQU	X'CC'			; BOARD STATUS PORT
DRESET	EQU	X'CE'			; DISK RESET PORT
;
; HERE IT IS!!!!!!!!!!!
;
	JP	START
;
	DEFB	12
	DEFB	'ADS Disk Formatter VERSION 1.3',13,10
	DEFB	'Last update: 2/25/86 18:34',13,10
	DEFB	13,10
	DEFB	'Please report problems and suggestions',13,10
	DEFB	26
;
START:	IN	A,(MPIOBST)		; GET CURRENT STATUS
	AND	X'F8'			; MASK OUT DRIVE SELECTS
	OR	X'01'			; ASSUME FLOPPY
	OUT	(MPIOBST),A		; SET FLOPPY
	OUT	(DRESET),A		; RESET TOO
	LD	DE,STRTM		; GET START UP MESSAGE
START2:	CALL	PRMSG			; PRINT IT
GETDSK:	CALL	GETKEY			; GET A CHARACTER FROM KEYBD
	CP	'A'			; COMPARE TO A
	JR	C,GETDSK		; IGNORE IF LESS
	CP	'P'+1			; COMPARE TO P
	JR	NC,GETDSK		; IGNORE IF GREATER
	CALL	PRCHR			; PRINT THE DISK IDENTIFIER
	SUB	X'41'			; MAKE THE DISK ID USEABLE
	LD	(DID),A			; STORE DRIVE ID
	LD	C,A			; PUT INTO C
	LD	A,X'1B'			; SEL DSK
	CALL	GOBIOS			; CALL SEL DSK
	LD	A,H			; H INTO A
	OR	L			; AND L TOO TO SEE IF TOTAL 0
	JR	NZ,GETD20		; IF NOT 0 CONTINUE
	LD	DE,NODSKM		; GET NO DISK MSG
	JR	START2			; GET NEW DISK
GETD20:	LD	(DPHA),HL		; STORE DPH ADDR
	LD	A,(DID)			; GET DRIVE NUMBER
	CP	RAMDSK1			; WAS IT MEU DRIVE
	JP	Z,PRDY			; IF SO, SKIP OTHER JUNK
	CP	RAMDSK2			; WAS IT THE OTHER MEU DRIVE
	JP	Z,PRDY			; IF SO, SKIP OTHER JUNK TOO
;
	LD	DE,SCTRM		; GET THE SKEW MSG
	CALL	PRMSG			; PRINT IT
GETINT:	CALL	GETKEY			; GET A KB CHAR
	CP	'0'			; WAS IT <0
	JR	C,GETINT		; IF SO TRY AGAIN
	CP	'9'+1			; WAS IT >9
	JR	NC,GETINT		; IF SO TRY AGAIN
	CALL	PRCHR			; PRINT GOOD SKEW
	SUB	X'30'			; MAKE IT USEABLE
	LD	(AUX),A			; STORE FOR LATER USE
;
	LD	DE,VFYQM		; GET VERIFY QUESTION
	CALL	PRMSG			; PRINT IT
GETVFY:	CALL	GETKEY			; GET A CHARACTER
	CP	'Y'			; WAS IT Y
	JR	Z,GETV10		; IF SO, CONTINUE
	CP	'N'			; WAS IT AN N
	JR	NZ,GETVFY		; IF NOT GET ANOTHER CHAR
GETV10:	CALL	PRCHR			; PRINT ANSWER
	SUB	'N'			; MAKE 0 IF NO
	LD	(DOVFY),A		; STORE IT
;
PRDY:	LD	DE,RDYM			; GET HERE WE GO MSG
	CALL	PRMSG			; PRINT IT
GETRDY:	CALL	GETKEY			; GET A KB CHAR
	CP	'Y'			; ARE WE READY
	JR	NZ,GETRDY		; IF NOT, WAIT TILL WE ARE
	CALL	PRCHR			; PRINT THE ANSWER
;
	LD	HL,(DPHA)		; DISK PARAMETER HEADER ADDR
	LD	DE,X'000A'		; OFFSET FOR DPB
	ADD	HL,DE			; POINT TO DBP
	LD	E,(HL)			; GET LOW BYTE OF DPB ADDR
	INC	HL			; NEXT BYTE
	LD	D,(HL)			; GET HIGH BYTE
	PUSH	DE			; PUSH DE
	POP	IX			; POP INTO IX
	LD	A,(IX+X'00')		; GET LOW BYTE OF SECTORS/TRACK
	LD	(SPT),A			; SAVE IT
	LD	A,(IX+X'07')		; GET LOW BYTE OF DIR ENTRIES
	INC	A			; ADD 1
	OR	A			; CLEAR CARRY
	RRA				; DIV 2
	OR	A			; CLEAR CARRY
	RRA				; DIV 2 MORE
	LD	(CKS),A			; STORE IT
	LD	A,(IX+X'0D')		; GET LOW BYTE OF RESERVED TRACKS
	LD	(OFF),A			; SAVE NUMBER OF RESERVED TRACKS
;
	LD	A,(AUX)			; GET INTERLEAVE
	LD	(UDAUX),A		; STORE TO SEND TO CONTROLLER
;
	LD	A,(DID)			; GET DISK NUMBER
	CP	RAMDSK1			; WAS IT MEU
	JP	Z,MAKDIR		; IF SO JUST MAKE A DIRECTORY
	CP	RAMDSK2			; WAS IT OTHER MEU
	JP	Z,MAKDIR		; IF SO JUST MAKE A DIRECTORY
;
	CALL	DCONF			; CHECK FOR DS DRIVE
;
	LD	A,(TWOSID)		; GET DRIVE TYPE
	OR	A			; IS IT TWO SIDED
	JR	Z,PREFOR		; JUMP IF NOT
	LD	DE,SID1M		; ELSE, SIDE 1
	CALL	PRMSG			; PRINT IT
;
PREFOR:	LD	DE,FORMTM		; GET THE FORMAT MSG
	CALL	PRMSG			; PRINT IT
	LD	A,FMTCMD		; LOAD FORMAT COMMAND
	LD	(UDCMND),A		; STORE IT
	CALL	GODOIT			; GO FORMAT THE DISK
;
	LD	A,(TWOSID)		; GET DRIVE TYPE
	OR	A			; IS IT DS
	JR	Z,PREVER		; JUMP IF NOT
	LD	A,(DID)			; ELSE GET DRIVE NUMBER
	SET	7,A			; TURN ON HEAD 2
	LD	(UDFBUN),A		; STORE UNIT
	LD	DE,SID2M		; SIDE 2
	CALL	PRMSG			; PRINT IT
	CALL	GODOIT			; FORMAT SIDE 2
;
PREVER:	LD	A,(DOVFY)		; GET VERIFY FLAG
	OR	A			; IS IT SET
	JR	Z,MAKDIR		; IF NOT, DONT VERIFY
;
	LD	A,(SPT)			; GET # OF SECTORS/TRACK
	DEC	A			; RELATIVE TO 0
	LD	(UDAUX),A		; STORE IT
;
	LD	A,(TWOSID)		; GET DRIVE TYPE
	OR	A			; IS IT DS
	JR	Z,PREV2			; JUMP IF NOT
	LD	A,(DID)			; GET DRIVE ID
	LD	(UDFBUN),A		; STORE IT, SIDE 1
	LD	DE,SID1M		; SIDE 1
	CALL	PRMSG			; PRINT IT
;
PREV2:	LD	DE,VERFYM		; GET VERIFY MSG
	CALL	PRMSG			; PRINT IT
	LD	A,VFYCMD		; LOAD VERIFY COMMAND
	LD	(UDCMND),A		; STORE IT
	CALL	GODOIT			; GO VERIFY
;
	LD	A,(TWOSID)		; GET DRIVE TYPE
	OR	A			; IS IT DS
	JR	Z,MAKDIR		; JUMP IF NOT
	LD	A,(DID)			; GET DRIVE ID
	SET	7,A			; SET SIDE 2
	LD	(UDFBUN),A		; STORE IT
	LD	DE,SID2M		; SIDE 2
	CALL	PRMSG			; PRINT IT
	CALL	GODOIT			; VERIFY SIDE 2
;
MAKDIR:	LD	DE,DIRFMT		; GET DIR FORMAT MSG
	CALL	PRMSG			; PRINT IT
	LD	HL,X'0080'		; DMA BUFFER
	LD	B,128			; SECTOR SIZE
FILBUF:	LD	(HL),X'E5'		; FILL IT WITH E5'S
	INC	HL			; NEXT BYTE
	DJNZ	FILBUF			; IF NOT DONE, KEEP FILLING
	LD	BC,X'0080'		; DMA BUFFER
	LD	A,X'24'			; SET DMA
	CALL	GOBIOS			; SET IT PLEASE
	LD	A,(OFF)			; GET OFFSET
	LD	C,A			; PUT IT INTO C FOR BIOS CALL
	LD	A,X'1E'			; SET TRK
	CALL	GOBIOS			; DO IT
	XOR	A			; LOAD A 0
WDIR:	LD	C,A			; PUT IT INTO C
	LD	(UDSCTR),A		; SET SECTOR
	LD	A,(CKS)			; GET LAST SECTOR TO FORMAT
	CP	C			; ARE WE THERE YET
	JP	Z,EXIT			; IF SO, EXIT PROGRAM
	LD	A,X'21'			; SET SEC
	CALL	GOBIOS			; SET THE SECTOR
	LD	A,X'2A'			; WRITE
	CALL	GOBIOS			; WRITE IT
	OR	A			; CHECK FOR ERROR
	JP	NZ,ERROR		; ERROR IF NOT 0
	LD	A,(UDSCTR)		; GET SECTOR AGAIN
	INC	A			; INCREMENT IT
	JR	WDIR			; SEE WDIR
;
GODOIT:	XOR	A			; LOAD A 0
	LD	(DECTRK),A		; MAKE DECIMAL TRACK COUNTER 0
	LD	(UDTRAK),A		; MAKE TRACK 0
	LD	(UDSCTR),A		; MAKE SECTOR 0
FORMAT:	LD	A,(DECTRK)		; GET TRACK
	LD	DE,TRKNPS		; GET POSITION TO PRINT IT
	CALL	PRMSG			; GOTO POSITION
	CALL	PRHEX			; PRINT TRACK
	CALL	SETUP			; SET UP DISK CONTROLLER
	CALL	WAITST			; GET STATUS
	CP	2			; ARE WE OK?
	JP	NC,ERROR		; IF NOT OK THEN ERROR
	LD	A,(DECTRK)		; GET DECIMAL TRACK COUNT
	INC	A			; INCREMENT
	OR	A			; CLEAR CARRY FLAG
	DAA				; ADJUST COUNT
	LD	(DECTRK),A		; STORE IT BACK
	LD	A,(UDTRAK)		; GET TRACK POSITION
	INC	A			; INCREMENT
	LD	(UDTRAK),A		; STORE IT BACK
	CP	TPDF			; IS IT 1 PAST THE LAST TRACK
	JR	NZ,FORMAT		; IF NOT DO NEXT TRACK
	RET				; RETURN
;
DCONF:	LD	A,STACMD		; STATUS COMMAND
	LD	(UDCMND),A		; STORE IT
	LD	A,(DID)			; GET DRIVE ID
	SET	7,A			; SET SIDE 2
	LD	(UDFBUN),A		; STORE IT
	XOR	A			; CLEAR
	LD	(UDTRAK),A		; ZERO TRACK
	LD	(UDSCTR),A		; ZREO SECTOR
	LD	(TWOSID),A		; MAKE SS
	CALL	SETUP			; STATUS
	CALL	WAITST			; GET STATUS
	OR	A			; IS IT DS
	JR	NZ,RESDR		; JUMP IF NOT DBL SIDED
	LD	A,X'FF'			; SET 2 SIDE FLAG
	LD	(TWOSID),A		; STORE IT
RESDR:	LD	A,(DID)			; GET DRIVE ID
	LD	(UDFBUN),A		; RESTORE IT
	RET				; EXIT
;
SETUP:	IN	A,(DCTLR1)		; GET STATUS
	AND	CBUSY			; IS IT BUSY
	JR	NZ,SETUP		; IF SO WAIT
	LD	HL,PRMLST		; GET PARAMETER LIST
	CALL	WORDY			; WAIT TILL CONTROLLER READY TO SEND
	LD	A,(HL)			; GET CMND
	INC	HL			; POINT TO NEXT BYTE OF CMND LST
	CPL				; INVERT SO NORMAL
	OUT	(DCTLR1),A		; SEND IT
	LD	B,4			; NUMBER OF CMNDS TO SEND
GETPRM:	LD	A,(HL)			; GET PARAMETER
	INC	HL			; POINT TO NEXT BYTE OF CMND
	CALL	SEND			; SEND IT
	DJNZ	GETPRM			; IF NOT DONE, GET THE REST
	RET				; RETURN
;
SEND:	CALL	WORDY			; WAIT TILL READY TO SEND
	CPL				; INVERT DATA
	OUT	(DDATA1),A		; SEND IT
	RET				; RETURN
;
WORDY:	PUSH	AF			; SAVE BYTE TO SEND
WRDY10:	IN	A,(DCTLR1)		; GET STATUS
	AND	ORDY			; OUTPUT READY?
	JR	NZ,WRDY10		; IF NOT THEN WAIT
	POP	AF			; RESTORE BYTE
	RET				; RETURN
;
WAITST:	IN	A,(DCTLR1)		; GET STATUS
	AND	CBUSY			; BUSY?
	JR	NZ,WAITST		; IF SO, WAIT
WAIS10:	IN	A,(DCTLR1)		; GET STATUS AGAIN
	AND	IRDY			; ANYTHING TO INPUT?
	JR	NZ,WAIS10		; IF NOT, WAIT
	IN	A,(DDATA1)		; GET TERM BYTE
	CPL				; MAKE IT NORMAL
	RET				; RETURN
;
ABORT:	LD	DE,ABRTM		; GET ABORT MESSGAE
	CALL	PRMSG			; PRINT IT
	JP	0			; EXIT
;
ERROR:	LD	DE,ERRM			; GET CONTROLLER ERROR MSG
	CALL	PRMSG			; PRINT IT
	JP	0			; EXIT
;
EXIT:	LD	DE,DONEM		; GET DONE MESSAGE
	CALL	PRMSG			; PRINT IT
EXIT05:	CALL	GETKEY			; GET A CHARACTER
	CP	'C'			; WAS IT CONTINUE
	JP	Z,PRDY			; GOTO WAIT POINT
	CP	'R'			; WAS IT RESTART
	JR	NZ,EXIT05		; IF NOT, EXIT
	LD	DE,STRTM2		; GET WARM START MSG
	JP	START2			; GOT GET DSK NUMBER
;
GOBIOS:	PUSH	AF			; SAVE AF FOR LATER
	LD	A,(2)			; GET BASE PAGE OF BIOS
	LD	H,A			; INTO H IT GOES
	POP	AF			; GET BIOS OFFSET
	LD	L,A			; INTO L
	JP	(HL)			; GOTO BIOS FUNCTION
;
PRMSG:	PUSH	HL
	PUSH	BC
	PUSH	AF
	EX	DE,HL
PRM10:	LD	A,(HL)
	OR	A
	JR	Z,PRM20
	LD	E,A
	LD	C,6
	PUSH	HL
	CALL	BDOS
	POP	HL
	INC	HL
	JR	PRM10
PRM20:	POP	AF
	POP	BC
	POP	HL
	RET
;
PRCHR:	PUSH	HL
	PUSH	DE
	PUSH	AF
	LD	C,6
	LD	E,A
	CALL	BDOS
	POP	AF
	POP	DE
	POP	HL
	RET
;
GETKEY:	PUSH	HL
	PUSH	DE
GETK10:	LD	C,6
	LD	E,X'FF'
	CALL	BDOS
	OR	A
	JR	Z,GETK10
	CP	X'60'
	JR	C,GETK20
	SUB	X'20'
GETK20:	POP	DE
	POP	HL
	CP	3
	JP	Z,ABORT
	RET
;
PRHEX:	PUSH	AF
	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	PRH10
	CALL	PRCHR
	POP	AF
	CALL	PRH10
	CALL	PRCHR
	POP	AF
	RET
PRH10:	AND	X'0F'
	ADD	A,X'90'
	DAA
	ADC	A,X'40'
	DAA
	RET
;
STRTM:	DEFB	12
STRTM2:	DEFB	28
	DEFB	'======== ADS Disk Formatter v1.3 '
	DEFB	'=============================== Kontron ======',13,10
	DEFB	10
	DEFB	10
	DEFB	'Drive to format?   (A..P) '
	DEFB	27,'k'
	DEFB	0
;
SCTRM:	DEFB	13,10
	DEFB	'Sector interleave? (0..9) '
	DEFB	27,'k'
	DEFB	0
;
VFYQM:	DEFB	13,10
	DEFB	'Verify formatting?  (Y/N) '
	DEFB	0
;
RDYM:	DEFB	27,'Y',32+7,32+0
	DEFB	'Press the <Y> key to begin formatting or <CTRL-C> to exit: '
	DEFB	27,'k'
	DEFB	0
;
FORMTM:	DEFB	27,'3'
	DEFB	27,'Y',32+9,32+8
	DEFB	'Formatting track:'
	DEFB	0
;
VERFYM:	DEFB	27,'Y',32+9,32+8
	DEFB	'Verifying '
	DEFB	0
;
DIRFMT:	DEFB	27,'3'
	DEFB	27,'Y',32+9,32+8
	DEFB	'Formatting directory...'
	DEFB	27,'K'
	DEFB	0
;
SID1M:	DEFB	27,'Y',32+9,32+28
	DEFB	', side 1'
	DEFB	0
;
SID2M:	DEFB	27,'Y',32+9,32+28
	DEFB	', side 2'
	DEFB	0
;
TRKNPS:	DEFB	27,'Y',32+9,32+26
	DEFB	0
;
ERRM:	DEFB	1
	DEFB	26
	DEFB	'FATAL ERROR: Please check the drive and your disk...'
	DEFB	27,'4'
	DEFB	0
;
ABRTM:	DEFB	27,'k'
	DEFB	1
	DEFB	26
	DEFB	'Exiting...'
	DEFB	27,'K'
	DEFB	27,'4'
	DEFB	0
;
DONEM:	DEFB	27,'Y',32+9,32+8
	DEFB	'Done.'
	DEFB	27,'K'
	DEFB	1
	DEFB	26
	DEFB	'Press the <R> key to restart, <C> to continue, '
	DEFB	'or <CTRL-C> to exit: '
	DEFB	27,'4'
	DEFB	0
;
NODSKM:	DEFB	27,'3'
	DEFB	27,'Y',32+7,32+0
	DEFB	'I can''t format a non-existent drive.'
	DEFB	27,'Y',32+3,32+26
	DEFB	27,'4'
	DEFB	0
;
DPHA:	DEFW	X'0000'
;
SPT:	DEFS	1			; SECTORS PER TRACK
OFF:	DEFS	1			; OFFSET FOR RESERVED TRACKS
CKS:	DEFS	1			; DIRECTOR CHECK SIZE I.E. DIRECTORY
;
AUX:	DEFS	1
;
DOVFY:	DEFS	1
;
DECTRK:	DEFS	1
;
TWOSID:	DEFS	1
;
DID:	DEFS	1
;
PRMLST:
UDCMND:	DEFS	1
UDFBUN:	DEFS	1
UDTRAK:	DEFS	1
UDSCTR:	DEFS	1
UDAUX:	DEFS	1
;
	END
